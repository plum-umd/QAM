\section{The Quantum Abstract Machine:  Syntax and Semantics} \label{sec:qam}

Essentially, quantum network protocols describe communication procedures 
among different quantum computers via the connections through classical network devices. 
In quantum teleportation (\Cref{sec:background}), there are two main procedures: 
1) a quantum message is transformed from Alice to Bob, 
and 2) a quantum entangled channel is built between Alice and Bob and causes Alice and Bob a qubit each to transform the message.
In a practical quantum network protocol, such as QCast and QPass \cite{10.1145/3387514.3405853}, 
there is another procedure, operated by classical computers, to determine how an optimized quantum channel is established to send a message from Alice to Bob.
If Alice and Bob is close enough to establish a direct entangled channel, the situation is the same as quantum teleportation;
otherwise, there is a complicated entangled qubit group that connects Alice and Bob as well as all the intermediate router stations,
so that the message can be sent from Alice to Bob. During the process, $n$ intermediate router stations cause $2n$ additional channels to establish the channel.

\begin{figure}[t]
{\small
\begin{center}
\begin{tikzpicture}[node distance={1cm}, thick, main/.style = {draw, circle}] 
\node[main] (1) {$a$}; 
\node[main] (2) [right of=1] {$r_1$};
\node[main] (3) [right of=2] {$r_4$};
\node[main] (4) [right of=3] {$b$};
\node[main] (5) [above right=0.5cm and 1.5cm of 1] {$r_2$};
\node[main] (6) [right of=5] {$r_3$};
\draw[-] (1) --  (2);
\draw[-] (2) --  (3);
\draw[-] (3) --  (4);
\draw[-] (1) --  (5);
\draw[-] (5) --  (6);
\draw[-] (6) --  (3);
\end{tikzpicture}
\end{center}
}
\caption{QPass Example Path Connectivity}
  \label{fig:q-pi-example}
\end{figure}

We model these quantum network protocols via an abstract machine framework that represents the above procedures.
We use a cell structure $\qcell{}$ to represent a conceptual device involving in the protocol communication.
For example, $\qcell{P}^{n}_{c}$ is a device named $c$ with $n$ qubit recourse and its program content is $P$.
In the section, we introduce the quantum abstract machine (QAM) syntax and semantics, following by the trace refinement definition for QAM processes. We use quantum teleportation, QCast and QPass as running examples.
QPass is a hybrid classical quantum network protocol. It contains a static classically generated graph describing the connectivity of different parties involved in a communication.
In \Cref{fig:q-pi-example}, a message is sent from node $a$ to $b$, and nodes $r_1$ to $r_4$ are intermediate routers.
A message is sent via either the path $a$, $r_1$, $r_4$, and $b$, or $a$, $r_2$, $r_3$, $r_4$ and $b$.

\begin{figure}[t]
{\small
  \[\begin{array}{llcl} 
      \texttt{Variables} & x,y \\
      \texttt{Probability} & p\\
      \texttt{Messages} & m\\
    \texttt{Channels} & c\\
    \texttt{Time Stamps} & \tau\\
      \texttt{Actions} & A & ::= & \emptyset \mid \qsend{p}{c}{m} \mid \qrev{c}{x} \\
      \text{Process} & P,Q & ::= & 0 \mid A.P \\
      \texttt{Sets} & \Ss & ::= & (\langle A (\texttt{|} P )^?\rangle^{n}_{c})^* \\
      \texttt{Relations} & \Rs & ::= & [c \times c \times p] \\
      \texttt{Relation Functions} & \Fs & ::= & \tau \to \Rs\\
      \texttt{Program Configuration} & \Ls & ::= & \Ss \qcell{\Rs}_r\\
      \texttt{Configuration} & \Cs & ::= & \qcell{\Ls}_{p}\qcell{\Fs}_{f}\qcell{\tau}_{t}
    \end{array}
  \]
}
\caption{Quantum Pi Syntax}
  \label{fig:q-pi-syntax}
\end{figure}


\subsection{Syntax} \label{sec:qamsyntax}

As shown in \Cref{fig:q-pi-syntax}, the execution of a QAM program relies on the concept of 
a configuration that describes conceptual computer components for QAM program interactions.
A configuration can possibly contain many cell structures $\qcell{\Theta}_{\eta}$, where $\Theta$ is the content of $\eta$ is the name.
For example, $\qcell{\Ls}_{p}$ is a program execution cell with name $p$, and program execution configuration as its content $\Ls$,
Cell $\qcell{\Fs}_{f}$ holds a function $\Fs$ representing the dynamically updated network node connectivity with respect to time, and $\qcell{\tau}_{t}$ is a global time cell representing periods of time for updating the connectivity graph.

Program executions represent multiple communications of quantum messages through different nodes in a network.
We assume that a single message communication always happens presently within a global time period so that during a message communication, the global clock remains the same.
A program execution configuration acts as the content $\Ls$ of the program execution cell $\qcell{\Ls}_{p}$ with the syntax $\Ss \qcell{\Rs}_r$, where cell $\qcell{\Rs}_r$ stores the node connectivity at a time, $\Ss$ is a set of cells representing different nodes.
The content $\Rs$ in a relation cell contains relations defining the connectivity of computer locations.
Each relation triple defines an adjacent pair of two locations, i.e., 
a computer can send a message to another location only if the two locations are adjacent.
There is also a probability value defining the probability of the successful rate of the communication between the two locations.

In a node cell, $c$ represents the node name and $n$ represents the number of qubit resources in the node.
$A (\texttt{|} P )^?$ is a Pi-calculus lite process language representing the communication program content in the node.
$A$ represents a message action that is about to send and receive from the node. $P$ represents a possible local process for the node to execute after it receives a message.
An action is either a message send ($\qsend{p}{c}{m}$) or receipt ($\qrev{c}{x}$) operation,
with $c$ being a channel name and $m$ is a message. $p$ is the likelihood of the send operation.
A local process consists with a chain of actions ($A.P$) that ends at a terminated process ($0$).
If a node cell only contains a singleton process,
it means that the cell is not ready for communication and the actions in the process will be transmitted to other cells.

{\small
\[
\begin{array}{l}
\texttt{S} \qcell{\texttt{R}}_r \equiv 
\Cella{\qsend{1}{c}{m}|0}{10}{a}\Cella{0}{10}{r_1}\Cella{0}{10}{r_2}\Cella{0}{10}{r_3}\Cella{0}{10}{r_4}\Cella{\qrev{c}{m}.0}{10}{b} 
\\\qquad\qquad
\qcell{(a,r_1,0.5), (a,r_2,0.5), (r_1, r_4, 0.5), (r_2, r_3, 0.5), (r_3,r_4, 0.5), (b,r_4,0.5)} 
\end{array}
\]
}

As an example of the QAM syntax, the above program execution configuration defines the program to send a message from location $a$ to $b$.
The first line corresponds to node cells $\texttt{S}$, containing the target and destination nodes $a$ and $b$ as well as intermediate routers $r_1$ to $r_4$; while the second line corresponds to relation cell $\qcell{\texttt{R}}_r$ capturing the connectivity in \Cref{fig:q-pi-example}.

\begin{figure}[t]
{\small
  \begin{mathpar}
   
   \inferrule[GenChan]{}
       {\Cellb{\qsend{p}{c}{m}}{i}{a}\Cellb{}{j}{b} \qcell{\{(a,b,p')\}\cup R})
        \longrightarrow (\Cellb{}{i-}{a}\Cellb{\qsend{(p\cdot p')}{c}{m}}{j-}{b},\{(a,b)\}\cup R)}


   \inferrule[GenQubit]{}
       {\Cellb{}{n}{a}\longrightarrow \Cellb{}{n+}{a}}
      
  \inferrule[Communication]{}
      { \qsend{p}{c}{m}\texttt{|} \qrev{c}{x}.P \xrightarrow{p.c.m}P[m/x]}
    
  \inferrule[RelationUp]{}
      { \qcell{\Ss \qcell{\Rs}}_{p}\qcell{\Fs}_{f}\qcell{t}_{t} \longrightarrow \qcell{\Ss \qcell{\Fs(t)}}_{p}\qcell{\Fs}_{f}\qcell{t}_{t}}

  \inferrule[TimeUp]{}
      {\qcell{t}_{t} \longrightarrow \qcell{t+}_{t}}

  \end{mathpar}
}
\caption{Quantum Pi Semantics}
  \label{fig:q-pi-semantics}
\end{figure}


\begin{figure}[t]
{\small
{\hspace*{-10em}
\begin{tikzpicture}[node distance={1.5cm}, thick, main/.style = {}] 
\node[main] (1) {S$\langle\{(a,r_1,0.5), (a,r_2,0.5)\}\cup$R$\rangle$}; 
\node[main] (2) [below left=0.5cm and 0.35cm of 1] {$\Cella{0}{9}{a}$ $\Cella{\qsend{0.5}{c}{m}|0}{9}{r_1}$... $\langle\{(r_1,r_4)\}\cup$R$\rangle$}; 
\node[main] (3) [below right=0.5cm and 0.35cm of 1] {\text{\ \ \ \ \ \ }$\Cella{0}{9}{a}$ $\Cella{\qsend{0.5}{c}{m}|0}{9}{r_2}$..., $\qcell{\{(r_2,r_3)\}\cup\text{R}}$}; 
\node[main] (4) [below of=2] {$\Cella{0}{8}{r_1}$ $\Cella{\qsend{0.25}{c}{m}|0}{9}{r_4}$... $\langle\{(r_4,b)\}\cup$R$\rangle$};
\node[main] (5) [below of=3] {\text{\ \ \ \ \ \ }$\Cella{0}{8}{r_2}$ $\Cella{\qsend{0.25}{c}{m}|0}{9}{r_3}$..., $\qcell{\{(r_3,r_4)\}\cup\text{R}}$};
\node[main] (6) [below of=4] {$\Cella{0}{8}{r_4}$ $\Cella{\qsend{0.125}{c}{m}|\qrev{c}{m}.0}{9}{b}$... $\qcell{\text{R}}$};
\node[main] (7) [below of=5] {\text{\ \ \ \ \ \ \ \ \;}$\Cella{0}{8}{r_3}$ $\Cella{\qsend{0.125}{c}{m}|0}{9}{r_4}$..., $\qcell{\{(r_4,b)\}\cup\text{R}}$};
\node[main] (8) [below of=6] {$\Cella{0}{9}{b}$... $\qcell{\text{R}}$};
\node[main] (9) [below of=7] {\text{\ \ \ \ \ \ \ \ }$\Cella{0}{8}{r_4}$ $\Cella{\qsend{0.0625}{c}{m}|\qrev{c}{m}.0}{9}{b}$..., $\qcell{\text{R}}$};
\node[main] (10) [below of=9] {\text{\ \ \ \ \ \ }$\Cella{0}{n}{b}$... $\qcell{\text{R}}$};
\draw[->] (1) -- node[midway, above left] {} (2); 
\draw[->] (1) -- node[midway, above right] {} (3); 
\draw[->] (2) -- node[midway, right] {} (4); 
\draw[->] (4) -- node[midway, right] {} (6);
\draw[->] (6) -- node[midway, right] {$0.125.c.m$} (8); 
\draw[->] (3) -- node[midway, right] {} (5); 
\draw[->] (5) -- node[midway, right] {} (7); 
\draw[->] (7) -- node[midway, right] {} (9);
\draw[->] (9) -- node[midway, right] {$0.0625.c.m$}  (10); 
\end{tikzpicture} 
}
}
\caption{Quantum Machine Transitions for \Cref{fig:q-pi-example}}
  \label{fig:q-pi-example1}
\end{figure} 

\subsection{Semantics} \label{sec:qamsemantics}

A program configuration defines the instantaneous behaviors of executing a process with a fixed relation $\Rs$.
\Cref{fig:q-pi-semantics} defines the semantics of QAM.
Rules \rulelab{GenChan}, \rulelab{GenQubit}, and \rulelab{Communication} define the transition semantics for a program configuration.
Rule \rulelab{GenChan} suggests that an action $\qsend{p}{c}{m}$ is transmitted from one cell $\qcell{}_a$ to another $\qcell{}_b$,
if there is a triple relation $(a,b,p')$ in the relation cell. 
In this procedure, the action accumulates the probability value $p\cdot p'$.
In addition, each transmission requires the consumption of two qubits: each cell consumes one qubits.
Rule \rulelab{Communication} defines the behavior of a parallel process inside a program cell.
This is the only non-internal communication in the system. It represents that a message $c.m$
is eventually consumed by a cell representing a computer location, with the probability of $p$.
Rule \rulelab{GenQubit} generates a new qubit in a location to help transmit messages from one location to another.
An example machine is given in \Cref{fig:q-pi-example} and \Cref{fig:q-pi-example1}.
The protocol of the definition follows the QPASS model \cite{10.1145/3387514.3405853}. 
The example contains six distinct computer locations and we want to send messages from location $a$ to $b$.
Locations $r_1$, $r_2$, $r_3$, and $r_4$ are intermediate routers. 
\Cref{fig:q-pi-example} represents the connectivity of different computers. 
\Cref{fig:q-pi-example1} provides the transition computation tree of two possible ways of sending a message from $a$ to $b$.
The key is that the message $c.m$ is transmitted via different paths here, 
and in the left path, the success probability is $0.125$, while the right path provides a success probability rate of $0.0625$.
According to the QPASS model, we then select the left path as the main path for executing the message transmission.

On top of the program configuration, we have the whole configuration defined as $\Cs$ in \Cref{fig:q-pi-syntax}. 
While the program configuration contains cells for instantaneous communication,
the configuration $\Cs$ defines additional two cells $\qcell{\Fs}_{f}$ and $\qcell{t}_{t}$ for long term effects.
$\qcell{t}_{t}$ stores a global clock time $t$ representing periods of time. When $t$ is updated to $t+1$, the time passes a long enough period so that the relation $\Rs$ in the relation cell might not be a good representation of the connectivity of the system anymore.
Thus, we update the relation cell data by $\Fs(t)$ in rule \rulelab{RelationUp} in \Cref{fig:q-pi-semantics}.
In quantum computation, the success rate of transmitting data between two locations can change dramatically overtime.
In the recent development \cite{https://doi.org/10.48550/arxiv.2205.06300}, 
some protocols admit an experimental procedure to determine the success rates for connectivity pairs in the network for a time, and use the experimental rates to represent the probability values for pairs in a given of time.
The update of the relation by the function application $\Fs(t)$ represents the update of the success rates overtime in a protocol.
Rule \rulelab{TimeUp} represents the update of clocks overtime.



