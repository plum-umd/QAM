\section{Case Study: QPass and QCast Protocol}\label{sec:case-study}

\Cref{sec:qamsemantics1} uses QAM to define different properties for quantum network protocols.
Here, we see how we can extend the QAM system to capture the behaviors of real-world quantum network protocols, such as QPass and QCast. In addition, an additional rule set is defined to show how we can utilize QAM to define additional properties that many quantum network protocols were intended but failed to do. The two properties are to guarantee that every message must be delivered in a threshold probability, and different process cells can periodically generate new qubits.

\ignore{
In this section, we show how to use the quantum abstract machine to model two quantum network protocols: QPass and QCast. These two protocols are developed by Shi and Qian \textit{[cite]}. Since a large-scale quantum network has many devices, the goal of those protocols is to solve the entanglement routing problem and build long distance entanglement for multiple source-destination pairs concurrently. These protocols have four phases: at the first phase, all process cells of the network are informed about the source-target cell pairs. Then these s-d pairs are inputted to the routing algorithm at phase two. The algorithm will output paths between source and destination. (Phase two is also the phase that our abstract machine tries to simulate.) At the third phase, all process cells exchanges their link states to their neighbors through classical channel. The entanglement swap is performed at the fourth phase so the long distance entanglement is eventuality created for quantum teleportation. QPass and QCast protocols are similar in general and the differences between them will be discussed in the following sections. }


\subsection{Defining Qpass and QCast Protocols}

\begin{figure}[t]
{\footnotesize
  \begin{mathpar}

\mprset{flushleft}
  \inferrule[SP]{}
      {\qcell{R}{\cn{rel}}\pcell{A(c)}{c_1\rightarrow c_2}{\cn{comm}}\qcell{\cn{F}}{\cn{pred}}
        \longrightarrow 
            \qcell{R}{\cn{rel}}\pcell{A(c)}{c_1\rightarrow c_2}{\cn{comm}}\qcell{\exists p'\,.\,(c_1,c_2,p')\in \cn{sp}(R,c_1,c)}{\cn{pred}}}

  \inferrule[MP]{}
      {\pcell{\_}{n}{c_1}\pcell{\_}{m}{c_2}
        \qcell{R}{\cn{rel}}\pcell{A(c)}{c_1\rightarrow c_2}{\cn{comm}}\qcell{\cn{F}}{\cn{pred}}
    \\\qquad\longrightarrow 
      \pcell{\_}{n}{c_1}\pcell{\_}{m}{c_2}
  \qcell{\cn{up}(R,c_1,n,c_2,m)}{\cn{rel}}\pcell{A(c)}{c_1\rightarrow c_2}{\cn{comm}}
      \qcell{\exists p'\,.\,(c_1,c_2,p')\in \cn{mp}(R,c_1,c)}{\cn{pred}}}
  \end{mathpar}
}
{\footnotesize
\begin{center}
$A(c)\triangleq\qsend{p}{c}{m}^{t'}$
\end{center}
}
\caption{The additional rules for QPass and QCast based on \Cref{fig:q-pi-semantics3}, excluding rule \rulelab{Grant1}.}
  \label{fig:qpass-rule}
\end{figure}

We first discuss the QPass protocol definition in QAM, and then the QCast one.

\noindent\textbf{The QPass Protocol.}
There are two key observations that lead to QPass: 1) dynamically computing the success rate of each relation pair in the \cn{rel} cell is hard; and 2) it is more efficient to rely on the statically commutable shortest path as a fixed way of conveying messages between two process cells. Thus, QPass tried to test if a message transmission step is in the shortest path. 
In modeling QPass, we utilize the existing configuration and rules in \Cref{fig:q-pi-semantics3} except rule \rulelab{Grant1},
which is upgraded to rule \rulelab{SP} in \Cref{fig:qpass-rule}.

Rule \rulelab{SP} grants a message transmission from $c_1$ to $c_2$. 
In each step, when a message action $\qsend{p}{c}{m}^{t'}$ is conveyed from $c_1$ to $c_2$,
A validity check $\exists p'\,.\,(c_1,c_2,p')\in \cn{sp}(R,c_1,c)$ in cell \cn{pred} verifies if pair $(c_1,c_2)$ is a part of the shortest path from $c_1$ to $c$. Function $\cn{sp}(R,c_1,c)$ finds the shortest path from $c_1$ to $c$ based on the relation set $R$.
If the predicate is satisfied, the message transmission is granted, we then apply rule \cn{FC1} to purge everything and prepare for the next transitions.

{\footnotesize
\begin{center}
\[
\begin{array}{lll}
&
\pcellb{0}{0}{r_1}
\pcellb{A}{2}{\cn{Ann}}
\pcellb{0}{2}{r_2}
\pcellb{\qrev{\cn{Bob}}{x}.0}{2}{\cn{Bob}}
\qcellb{R}{\cn{rel}}
\qcellb{\emptyset}{\cn{comm}}
\qcellb{\cn{F}}{\cn{pred}}
\qcellb{3}{\cn{gt}}
\\[0.5em]
\longrightarrow
&
\pcellb{0}{0}{r_1}
\pcellb{0}{1}{\cn{Ann}}
\pcellb{A}{1}{r_2}
\pcellb{\qrev{\cn{Bob}}{x}.0}{2}{\cn{Bob}}
\qcellb{R}{\cn{rel}}
\pcellb{A}{\cn{Ann} \rightarrow r_2}{\cn{comm}}
\qcellb{\cn{F}}{\cn{pred}}
\qcellb{3}{\cn{gt}}
&
(\rulelab{GC1})
\\[0.5em]
\longrightarrow
&
\pcellb{0}{0}{r_1}
\pcellb{0}{1}{\cn{Ann}}
\pcellb{A}{1}{r_2}
\pcellb{\qrev{\cn{Bob}}{x}.0}{2}{\cn{Bob}}
\qcellb{R}{\cn{rel}}
\pcellb{A}{\cn{Ann} \rightarrow r_2}{\cn{comm}}
\qcellb{b}{\cn{pred}}
\qcellb{3}{\cn{gt}}
&
(\rulelab{SP})
\end{array}
\]
\end{center}
}
{\footnotesize
\begin{center}
$A\triangleq\qsend{1}{\cn{Bob}}{m}^3
\qquad
b\triangleq\exists p'\,.\,(\cn{Ann},r_2,p')\in \cn{sp}(R,\cn{Ann},\cn{Bob})=\cn{F}
$
\end{center}
}

Assume that we start with an initial configuration as the top one above.
The relation $R$ defines a graph connectivity as in \Cref{fig:examplepath}.
The system began with a limited $2$ pieces of qubit resources for every cell 
and $r_1$'s resources were consumed previously. 
At this point, a message at the \cn{Ann} cell is waiting to transmit to either $r_1$ or $r_2$,
but we cannot apply rule \rulelab{GC1} to convey the message to $r_1$, since it has no enough resource; therefore, we transmit
the message to cell $r_2$.
Since $r_2$ is not part of the shortest path from $\cn{Ann}$ to $\cn{Bob}$, the application of rule \cn{SP} disqualifies the transition by marking the \cn{pred} cell to be $\cn{F}$; thus, the final configuration is stuck.

\noindent\textbf{The QCast Protocol.}
The above example shows that QPass can be unreasonable sometimes.
Since all message transmission paths are statically computed as the shortest paths,
it is possible that non shortest paths, such as the message transmission from \cn{Ann} to $r_2$ above, are omitted in the execution.
QCast overcomes this drawback by estimating different success rates for pairs in the \cn{rel} cell
and select a path with the highest estimated success rate, instead of selecting the shortest path in QPass.
Additionally, we update estimated success rates dynamically to reflect the rate reductions causing by qubit resource
consumption in different process cells.

Similar to QPass modeling, we utilize the configuration pattern and rules in \Cref{fig:q-pi-semantics3} except rule \rulelab{Grant1},
which is upgraded to rule \rulelab{MP} in \Cref{fig:qpass-rule}.
There are two key differences between rule \rulelab{MP} and \rulelab{SP}.
First, we now check if the pair $(c_1,c_2)$ is in the maximum success rate path from $c_1$ to $c$, computed by the function $\cn{mp}(R,c_1,c)$. Instead of checking if the pair is in a shortest path from $c_1$ to $c$ in QPass, we now find the path that can deliver a message in a maximum chance by firstly computing the estimated success rates for all different paths from $c_1$ to $c$ and then selecting the one having the maximum value. Second, we proportionally reduce the estimated success rates that are associated with relation pair $c_1$ and $c_2$ in the \cn{rel} cell. The qubit resources in process cells $c_1$ and $c_2$ are reduced, so paths through these two cells have a less likelihood to successfully transmit messages, compared to the case when qubit resources are enough,
whose behavior is captured by function $\cn{up}(R,c_1,n,c_2,m)$.
The simple explanation for the \cn{up} function is that
for every pair $(c_l,c_r,p)$ in $R$, if $c_l$ and $c_r$ are one of $c_1$ (or $c_2$), whose current qubit resource is $n$ (or $m$), we multiply $p$ by $\frac{n}{n+1}$ (or$ \frac{m}{m+1}$). 

{\footnotesize
\begin{center}
\[
\begin{array}{lll}
&
\pcellb{0}{0}{r_1}
\pcellb{A}{2}{\cn{Ann}}
\pcellb{0}{2}{r_2}
\pcellb{\qrev{\cn{Bob}}{x}.0}{2}{\cn{Bob}}
\qcellb{R'}{\cn{rel}}
\qcellb{\emptyset}{\cn{comm}}
\qcellb{\cn{F}}{\cn{pred}}
\qcellb{3}{\cn{gt}}
\\[0.5em]
\longrightarrow
&
\pcellb{0}{0}{r_1}
\pcellb{0}{1}{\cn{Ann}}
\pcellb{A}{1}{r_2}
\pcellb{\qrev{\cn{Bob}}{x}.0}{2}{\cn{Bob}}
\qcellb{R'}{\cn{rel}}
\pcellb{A}{\cn{Ann}\rightarrow r_2}{\cn{comm}}
\qcellb{\cn{F}}{\cn{pred}}
\qcellb{3}{\cn{gt}}
&
(\rulelab{GC1})
\\[0.5em]
\longrightarrow
&
\pcellb{0}{0}{r_1}
\pcellb{0}{1}{\cn{Ann}}
\pcellb{A}{1}{r_2}
\pcellb{\qrev{\cn{Bob}}{x}.0}{2}{\cn{Bob}}
\qcellb{\cn{up}(R',\cn{Ann},1,r_2,1)}{\cn{rel}}
\pcellb{A}{\cn{Ann}\rightarrow r_2}{\cn{comm}}
\qcellb{b}{\cn{pred}}
\qcellb{3}{\cn{gt}}
&
(\rulelab{MP})
\end{array}
\]
\end{center}
}
{\footnotesize
\begin{center}
$A\triangleq\qsend{1}{\cn{Bob}}{m}^3
\qquad
b\triangleq \exists p'\,.\,(\cn{Ann},r_2,p')\in \cn{mp}(R,\cn{Ann},\cn{Bob})=\cn{T}
$
\end{center}
}

The main purpose of the dynamic estimated success rate update is to take into account the qubit resources as a factor in message transmission. The above example starts with a similar initial configuration as the one above in discussing QPass. 
The \cn{rel} cell content $R'$ is updated before the execution, as the estimated success rate for the pair between $\cn{Ann}$ and $r_1$ has $0$ success rate, as $(\cn{Ann},r_1,0)$, because cell $r_1$ has no qubit resource. Then, the \rulelab{MP} rule application at the end grants the transition by marking cell \cn{pred} to be \cn{T}, since the path from \cn{Ann} to \cn{Bob} via $r_2$ has a higher success rate than the one via $r_1$. Additionally, we update the connectivity table $R'$ to $\cn{up}(R',\cn{Ann},1,r_2,1)$, by reducing the success rate on pairs related to cells $\cn{Ann}$ and $r_2$, proportion to the qubit resource reductions in the two cells.

Notice that the $\cn{up}$ function in rule \rulelab{MP} is a parameterized user definable function. 
If we parameterize the \cn{up} function to not update any success rates for relation triples in \cn{rel} cell, i.e., $\cn{up}(R,c_1,n,c_2,m)=R$, we can show that QPass probabilistically trace refines QCast, which is stated as follows:

\begin{theorem}\label{def:traceeq1}\rm[QPass and QCast Trace Refinement]
Given an initial configuration $C$ as an instantiation of the configuration pattern in \Cref{fig:q-pi-semantics3}, 
(QPass,$C$) $\sqsubseteq^p$ (QCast,$C$).

\end{theorem}

\subsection{Additional Quantum Network Properties}
\label{sec:add-prop}

\begin{figure}[t]
{\footnotesize

$\textcolor{blue}{\text{Extended Syntax:}}\\$
  \[\begin{array}{llcl} 
      \texttt{Success Rate Threshold} & \mu & \in & \Rs  \\[0.2em]
      \texttt{Message Success Rate Database} & g & \in & \Ls \times \Ms \to \Rs \\[0.2em]
      \texttt{Qubit Gen. Period} & \nu & \in & \Ts  \\[0.2em]
      \textcolor{red}{\texttt{Configuration Pattern GRF. Success Rate}} & \textcolor{red}{C} & \textcolor{red}{::=} & 
\textcolor{red}{\overline{\varphi}\pcell{\alpha}{\beta}{\cn{comm}}
  \qcell{\cn{bool}}{\cn{pred}}\qcell{R}{\cn{rel}}\qcell{t}{\cn{gt}}\pcell{g}{\mu}{\cn{at}} }\\[0.2em]
      \textcolor{red}{\texttt{Configuration Pattern for Qubit Gen.}} & \textcolor{red}{C} & \textcolor{red}{::=} & 
\textcolor{red}{\overline{\varphi}\pcell{\alpha}{\beta}{\cn{comm}}
  \qcell{\cn{bool}}{\cn{pred}}\qcell{R}{\cn{rel}}\qcell{t}{\cn{gt}}\pcell{\cn{bool}}{\nu}{\cn{qi}} }
    \end{array}
  \]
$\textcolor{blue}{\text{Semantics:}}\\$
  \begin{mathpar}
\mprset{flushleft}
  \inferrule[HP]{}
      {\qcell{R}{\cn{rel}}\pcell{\qsend{p}{c}{m}^{t}}{c_1}{\cn{comm}}\qcell{\cn{F}}{\cn{pred}}\qcell{t'}{\cn{gt}}\pcell{g}{\mu}{\cn{at}}
\\\qquad
        \longrightarrow 
            \qcell{R}{\cn{rel}}\pcell{\qsend{p}{c}{m}^{t}}{c_1}{\cn{comm}}\qcell{f(t,t')\wedge g(c.m)<\mu}{\cn{pred}}
        \qcell{t'}{\cn{gt}}\pcell{g[c.m\mapsto g(c.m)\oplus p]}{\mu}{\cn{at}}
      }

  \inferrule[QI1]{}
      {\pcell{P}{n}{c}\qcell{t}{\cn{gt}}\pcell{\cn{F}}{\nu}{\cn{qi}}
        \longrightarrow 
        \pcell{P}{n}{c}\qcell{t}{\cn{gt}}\pcell{\nu\cn{|}t}{\nu}{\cn{qi}}
      }

  \inferrule[QI2]{}
      {\pcell{P}{n}{c}\pcell{\cn{T}}{\nu}{\cn{qi}}
        \longrightarrow 
        \pcell{P}{n\cn{+}}{c}\pcell{\cn{F}}{\nu}{\cn{qi}}
      }

  \inferrule[TI]{}
      {\qcell{t}{\cn{gt}}
        \longrightarrow 
        \qcell{t\cn{+}}{\cn{gt}} \\\cn{[owise]}
      }

  \end{mathpar}
}
\caption{The additional rules for guaranteeing high success rate of deliveries and qubit resource generation based on \Cref{fig:q-pi-semantics3}, excluding rule \rulelab{Grant2}.}
  \label{fig:mes-rule}
\end{figure}

There are many different properties that we want from a quantum network protocols.
Here, we introduce two of them that were discussed in the previous works but not captured by them. 
The first property is to guarantee a high success rate of every message delivery,
while the second one is to introduce qubit creation. 

\noindent\textbf{Guarantee High Probability of Message Deliveries.}
Quantum message sending has a certain chance of failure, which depends on the transmission distance.
To guarantee the success rate, one simple solution is to repeatedly send the message until a threshold is reached.
We introduce a new initial configuration \rulelab{HighConfig} to model such behavior,
with a new cell \cn{at} having a content map $g$, storing the current success rates for different messages $c.m$, and a flag $\beta$, the success rate threshold every message needs to satisfy in $g$.
We then introduce the \rulelab{HP} rule based on the \rulelab{TP} rule in \Cref{sec:qamsemantics}
for granting a message delivery.
A message $c.m$ is valid to deliver if it satisfies the time threshold $f(t,t')$
and its current success rate in $g$ is less than the threshold $\beta$.
Once the threshold is reached, we do not need additional repetition of sending $c.m$, so that we only need to grant message delivery that has not yet satisfied the threshold.
Additionally, every success message delivery increments ($g[c.m\mapsto g(c.m)\oplus p]$) the current success rate for that message in the \cn{at} cell.

{\footnotesize
\[
\begin{array}{ll}
\Cella{\comp{(\qsend{1}{c}{m}})}{10}{\cn{Cat}}\Cella{0}{10}{r_1}
\Cella{\comp{(\qrev{c}{x}.0)}}{10}{\cn{Dan}} 
\qcell{R}{\cn{rel}}
\qcell{\emptyset}{\cn{comm}}
\qcell{0}{\cn{gt}}
\qcell{f}{\cn{tp}}
\pcell{g}{0.36}{\cn{at}}
\\[0.2em]
\longrightarrow\;\;
\Cella{\parl{\qsend{1}{c}{m}}{\comp{(\qsend{1}{c}{m}})}}{10}{\cn{Cat}}
\Cella{0}{10}{r_1}
\Cella{\comp{(\qrev{c}{x}.0)}}{10}{\cn{Dan}} 
\qcell{R}{\cn{rel}}
\qcell{\emptyset}{\cn{comm}}
\qcell{0}{\cn{gt}}
\qcell{f}{\cn{tp}}
\pcell{g}{0.36}{\cn{at}}
&
(\rulelab{MT})
\\[0.2em]
\longrightarrow\;\;
\Cella{\parl{\qsend{1}{c}{m}^0}{\comp{(\qsend{1}{c}{m}})}}{10}{\cn{Cat}}
\Cella{0}{10}{r_1}
\Cella{\comp{(\qrev{c}{x}.0)}}{10}{\cn{Dan}} 
\qcell{R}{\cn{rel}}
\qcell{\emptyset}{\cn{comm}}
\qcell{0}{\cn{gt}}
\qcell{f}{\cn{tp}}
\pcell{g}{0.36}{\cn{at}}
&
(\rulelab{CT})
\\[0.2em]
\longrightarrow\;\;
\Cella{\comp{(\qsend{1}{c}{m}})}{9}{\cn{Cat}}
\Cella{\qsend{0.5}{c}{m}^0}{9}{r_1}
\Cella{\comp{(\qrev{c}{x}.0)}}{10}{\cn{Dan}} 
\qcell{R}{\cn{rel}}
\qcell{A}{\cn{comm}}
\qcell{0}{\cn{gt}}
\qcell{f}{\cn{tp}}
\pcell{g}{0.36}{\cn{at}}
&(\rulelab{GC})
\\[0.2em]
\longrightarrow\;...\;\longrightarrow
\\[0.2em]
\Cella{\comp{(\qsend{1}{c}{m}})}{9}{\cn{Cat}}
\Cella{0}{8}{r_1}
\Cella{\parl{\qsend{0.25}{c}{m}^0}{\comp{(\qrev{c}{x}.0)}}}{9}{\cn{Dan}} 
\qcell{R}{\cn{rel}}
\qcell{\emptyset}{\cn{comm}}
\qcell{2}{\cn{gt}}
\qcell{f}{\cn{tp}}
\pcell{g}{0.36}{\cn{at}}
\\[0.2em]
\longrightarrow\;\;
\Cella{\comp{(\qsend{1}{c}{m}})}{9}{\cn{Cat}}
\Cella{0}{8}{r_1}
\Cella{\parl{\qsend{0.25}{c}{m}^0}{\parl{\qrev{c}{x}.0}{\comp{(\qrev{c}{x}.0)}}}}{9}{\cn{Dan}} 
\qcell{R}{\cn{rel}}
\qcell{\emptyset}{\cn{comm}}
\qcell{2}{\cn{gt}}
\qcell{f}{\cn{tp}}
\pcell{g}{0.36}{\cn{at}}
&
(\rulelab{MT})
\\[0.2em]
\longrightarrow\;\;
\Cella{\comp{(\qsend{1}{c}{m}})}{9}{\cn{Cat}}
\Cella{0}{8}{r_1}
\Cella{\comp{(\qrev{c}{x}.0)}}{9}{\cn{Dan}} 
\qcell{R}{\cn{rel}}
\qcell{A'}{\cn{comm}}
\qcell{2}{\cn{gt}}
\qcell{f}{\cn{tp}}
\pcell{g}{0.36}{\cn{at}}
&
(\rulelab{PC})
\end{array}
\]
}
{\footnotesize
\begin{center}
$R\triangleq\{(\cn{Cat},r_1,0.5), (r_1,\cn{Dan},0.5)\}
\qquad
A\triangleq (\cn{Cat},r_1,\qsend{0.5}{c}{m}^0)
\qquad
A'\triangleq \qsend{0.25}{c}{m}^0
\qquad
g=\lambda x\,.\,0
$
\end{center}
}

We create message repetition by the $\comp{P}$ process, 
as the example configuration transitions above, which omit the \cn{pred} cell.
Here, both the sender and receiver cells have repetition processes, 
$\comp{(\qsend{1}{c}{m}^0)}$ and $\comp{(\qrev{c}{x}.0)}$.
When it is necessary, the \cn{MT} rule application generates additional sending/receiving process to send/receive a message.
After a \cn{MT} rule application to generate a single message sending $\qsend{1}{c}{m}$, 
a \cn{CT} rule application is applied to attach time stamp $0$ to the message.
Then, the message is transmitted to the \cn{Dan} cell
and we use rule \cn{MT} to generate a message receipt $\qrev{c}{x}.0$;
thus, a \cn{PC} rule application is applied to move the message to the \cn{comm} cell, waiting for its granting.
The configuration below finalizes the above configuration with the \cn{pred} cell.

{\footnotesize
\[
\begin{array}{ll}
\Cella{\comp{(\qsend{1}{c}{m}})}{9}{\cn{Cat}}
\Cella{0}{8}{r_1}
\Cella{\comp{(\qrev{c}{x}.0)}}{9}{\cn{Dan}} 
\qcell{R}{\cn{rel}}
\qcell{A(0)}{\cn{comm}}
\pcell{\emptyset}{2}{\cn{pred}}
\qcell{2}{\cn{gt}}
\qcell{f}{\cn{tp}}
\pcell{g}{0.36}{\cn{at}}
\\[0.2em]
\longrightarrow\;\;
\Cella{\comp{(\qsend{1}{c}{m}})}{9}{\cn{Cat}}
\Cella{0}{8}{r_1}
\Cella{\comp{(\qrev{c}{x}.0)}}{9}{\cn{Dan}} 
\qcell{R}{\cn{rel}}
\qcell{\emptyset}{\cn{comm}}
\pcell{f(0,2)\wedge 0 < 0.36}{0}{\cn{pred}}
\qcell{2}{\cn{gt}}
\qcell{f}{\cn{tp}}
\pcell{g'}{0.36}{\cn{at}}
&
(\rulelab{HP})
\\[0.2em]
\xrightarrow{0.25.c.m}  \;\;
\Cella{\comp{(\qsend{1}{c}{m}})}{9}{\cn{Cat}}
\Cella{0}{8}{r_1}
\Cella{\comp{(\qrev{c}{x}.0)}}{9}{\cn{Dan}} 
\qcell{R}{\cn{rel}}
\qcell{\emptyset}{\cn{comm}}
\pcell{\cn{false}}{0}{\cn{pred}}
\qcell{3}{\cn{gt}}
\qcell{f}{\cn{tp}}
\pcell{g'}{0.36}{\cn{at}}
&
(\rulelab{Com})
\\[0.2em]
\longrightarrow\;...\;\longrightarrow
\\[0.2em]
\Cella{\comp{(\qsend{1}{c}{m}})}{8}{\cn{Cat}}
\Cella{0}{6}{r_1}
\Cella{\comp{(\qrev{c}{x}.0)}}{8}{\cn{Dan}} 
\qcell{R}{\cn{rel}}
\qcell{A(3)}{\cn{comm}}
\pcell{\emptyset}{2}{\cn{pred}}
\qcell{5}{\cn{gt}}
\qcell{f}{\cn{tp}}
\pcell{g'}{0.36}{\cn{at}}
\\[0.2em]
\longrightarrow\;\;
\Cella{\comp{(\qsend{1}{c}{m}})}{9}{\cn{Cat}}
\Cella{0}{8}{r_1}
\Cella{\comp{(\qrev{c}{x}.0)}}{9}{\cn{Dan}} 
\qcell{R}{\cn{rel}}
\qcell{\emptyset}{\cn{comm}}
\pcell{f(0,2)\wedge 0.25 < 0.36}{0}{\cn{pred}}
\qcell{5}{\cn{gt}}
\qcell{f}{\cn{tp}}
\pcell{g_1}{0.36}{\cn{at}}
&
(\rulelab{HP})
\\[0.2em]
\xrightarrow{0.25.c.m}  \;\;
\Cella{\comp{(\qsend{1}{c}{m}})}{8}{\cn{Cat}}
\Cella{0}{6}{r_1}
\Cella{\comp{(\qrev{c}{x}.0)}}{8}{\cn{Dan}} 
\qcell{R}{\cn{rel}}
\qcell{\emptyset}{\cn{comm}}
\pcell{\cn{false}}{0}{\cn{pred}}
\qcell{5}{\cn{gt}}
\qcell{f}{\cn{tp}}
\pcell{g_1}{0.36}{\cn{at}}
&
(\rulelab{Com})
\\[0.2em]
\longrightarrow  \;\;
\Cella{0}{8}{\cn{Cat}}
\Cella{0}{6}{r_1}
\Cella{\comp{(\qrev{c}{x}.0)}}{8}{\cn{Dan}} 
\qcell{R}{\cn{rel}}
\qcell{\emptyset}{\cn{comm}}
\pcell{\cn{false}}{0}{\cn{pred}}
\qcell{5}{\cn{gt}}
\qcell{f}{\cn{tp}}
\pcell{g_1}{0.36}{\cn{at}}
&
(\rulelab{NT})
\\[0.2em]
\longrightarrow  \;\;
\Cella{0}{8}{\cn{Cat}}
\Cella{0}{6}{r_1}
\Cella{0}{8}{\cn{Dan}} 
\qcell{R}{\cn{rel}}
\qcell{\emptyset}{\cn{comm}}
\pcell{\cn{false}}{0}{\cn{pred}}
\qcell{5}{\cn{gt}}
\qcell{f}{\cn{tp}}
\pcell{g_1}{0.36}{\cn{at}}
&
(\rulelab{NT})
\end{array}
\]
}
{\footnotesize
\begin{center}
$
\begin{array}{l}
R\triangleq\{(\cn{Cat},r_1,0.5), (r_1,\cn{Dan},0.5)\}
\qquad
A(t)\triangleq \qsend{0.25}{c}{m}^t
\\[0.2em]
g=\lambda x\,.\,0
\qquad
g'=g[c.m \mapsto 0.25]
\qquad
g_1=g[c.m \mapsto 0.39]
\end{array}
$
\end{center}
}

In the above transition, we apply rule \rulelab{HP} to grant the message sending operation $\qsend{0.25}{c}{m}^0$, since $f(0,2)$ is equivalent to $2-0<5$ and $g(c.m)=0$ is less than the threshold $0.36$ associated with the \cn{at} cell.
In the \cn{at} cell, we updates $g$ for $c.m$ to be $0.25$.
We assume that if messages have the same channel $c$ and message name $m$, they refer to the same message,
so repetitions of a message $c.m$ refer to the same one in the \cn{at} cell.
The procedure can be repeated to send more copies of message $c.m$ and then we can use \rulelab{HP} and \rulelab{Com} rule applications to grant the message delivery. In the above example, after two repeating $c.m$ message deliveries, the current success rate of $c.m$ is $0.39$ which is beyond the $0.36$ threshold. Any additional repetition causes the system to be stuck, so we apply two consecutive \rulelab{NT} rule applications to turn away the two repetition process operations. 

\noindent\textbf{Modeling Qubit Generation.}
An useful case for quantum network protocols is to generate new qubit resources for supporting message transmissions.
For example, in the QPass protocol example above, if we can generate qubits for node $r_1$, we can then transmit the message via node $r_1$ without the problem of qubit resource lacking.
It is always that the generation of a qubit takes multiple time slots compare to transmitting/sending messages.

In modeling the qubit generation mechanism, we include a new cell \cn{qi} in configuration \rulelab{QIConfig} in \Cref{fig:mes-rule},
which determines if the qubit resource in a process cell can increment.
The additional flag $\nu$ is an integer defining the time period for generating a qubit.
Rule \rulelab{QI1} increments a qubit in cell $c$ if $\nu$ divides the current global time $t$ ($\nu \cn{|} t$),
while rule \rulelab{QI2} cleans up the \cn{qi} cell for next possible qubit increment computation.
By including the new rule \rulelab{QI1}, it is possible for a QAM system to reach deadlock,
because a system can be stuck due to lack of a qubit in a process cell, but in the very next time, the qubit resource in the cell can increment by applying rule \rulelab{QI1}; however, there is no rule in the system for the global clock cell \cn{gt} to increment by itself.
To overcome this, we include rule \rulelab{TI} here to allow self-increment in the \cn{gt} cell, 
with the flag $\cn{owise}$ meaning that the rule can be applied only if there is no other possible rules to apply.





