\section{Case Study: QPass and QCast Protocol}\label{sec:case-study}

\Cref{sec:qamsemantics1} uses QAM to define different properties for quantum network protocols.
Here, we see how we can extend the QAM system to capture the behaviors of real-world quantum network protocols, such as QPass and QCast. In addition, an additional rule set is defined to show how we can utilize QAM to define additional properties that many quantum network protocols were intended but failed to do. The two properties are to guarantee that every message must be delivered in a threshold probability, and different process cells can periodically generate new qubits.

\ignore{
In this section, we show how to use the quantum abstract machine to model two quantum network protocols: QPass and QCast. These two protocols are developed by Shi and Qian \textit{[cite]}. Since a large-scale quantum network has many devices, the goal of those protocols is to solve the entanglement routing problem and build long distance entanglement for multiple source-destination pairs concurrently. These protocols have four phases: at the first phase, all process cells of the network are informed about the source-target cell pairs. Then these s-d pairs are inputted to the routing algorithm at phase two. The algorithm will output paths between source and destination. (Phase two is also the phase that our abstract machine tries to simulate.) At the third phase, all process cells exchanges their link states to their neighbors through classical channel. The entanglement swap is performed at the fourth phase so the long distance entanglement is eventuality created for quantum teleportation. QPass and QCast protocols are similar in general and the differences between them will be discussed in the following sections. }


\subsection{Defining Qpass and QCast Protocols}\label{sec:case-qpass}

\begin{figure}[t]
{\footnotesize
  \begin{mathpar}

\mprset{flushleft}
  \inferrule[SP]{}
      {\qcell{R}{\cn{rel}}\pcell{A(c)}{c_1\rightarrow c_2}{\cn{comm}}\qcell{\cn{F}}{\cn{pred}}
        \longrightarrow 
            \qcell{R}{\cn{rel}}\pcell{A(c)}{c_1\rightarrow c_2}{\cn{comm}}\qcell{\exists p'\,.\,(c_1,c_2,p')\in \cn{sp}(R,c_1,c)}{\cn{pred}}}

  \inferrule[MP]{}
      {\pcell{\_}{n}{c_1}\pcell{\_}{m}{c_2}
        \qcell{R}{\cn{rel}}\pcell{A(c)}{c_1\rightarrow c_2}{\cn{comm}}\qcell{\cn{F}}{\cn{pred}}
    \\\qquad\longrightarrow 
      \pcell{\_}{n}{c_1}\pcell{\_}{m}{c_2}
  \qcell{\cn{up}(R,c_1,n,c_2,m)}{\cn{rel}}\pcell{A(c)}{c_1\rightarrow c_2}{\cn{comm}}
      \qcell{\exists p'\,.\,(c_1,c_2,p')\in \cn{mp}(R,c_1,c)}{\cn{pred}}}
  \end{mathpar}
}
{\footnotesize
\begin{center}
$A(c)\triangleq\qsend{p}{c}{m}^{t'}$
\end{center}
}
\caption{The additional rules for QPass and QCast based on \Cref{fig:q-pi-semantics3}, excluding rule \rulelab{Grant1}.}
  \label{fig:qpass-rule}
\end{figure}

We first discuss the QPass protocol definition in QAM, and then the QCast one.

\noindent\textbf{The QPass Protocol.}
There are two key observations that lead to QPass: 1) dynamically computing the success rate of each relation pair in the \cn{rel} cell is hard; and 2) it is more efficient to rely on the statically commutable shortest path as a fixed way of conveying messages between two process cells. Thus, QPass tried to test if a message transmission step is in the shortest path. 
In modeling QPass, we utilize the existing configuration and rules in \Cref{fig:q-pi-semantics3} except rule \rulelab{Grant1},
which is upgraded to rule \rulelab{SP} in \Cref{fig:qpass-rule}.

Rule \rulelab{SP} grants a message transmission from $c_1$ to $c_2$. 
In each step, when a message action $\qsend{p}{c}{m}^{t'}$ is conveyed from $c_1$ to $c_2$,
A validity check $\exists p'\,.\,(c_1,c_2,p')\in \cn{sp}(R,c_1,c)$ in cell \cn{pred} verifies if pair $(c_1,c_2)$ is a part of the shortest path from $c_1$ to $c$. Function $\cn{sp}(R,c_1,c)$ finds the shortest path from $c_1$ to $c$ based on the relation set $R$.
If the predicate is satisfied, the message transmission is granted, we then apply rule \cn{FC1} to purge everything and prepare for the next transitions.

{\footnotesize
\begin{center}
\[
\begin{array}{lll}
&
\pcellb{0}{0}{r_1}
\pcellb{A}{2}{\cn{Ann}}
\pcellb{0}{2}{r_2}
\pcellb{\qrev{\cn{Bob}}{x}.0}{2}{\cn{Bob}}
\qcellb{R}{\cn{rel}}
\qcellb{\emptyset}{\cn{comm}}
\qcellb{\cn{F}}{\cn{pred}}
\qcellb{3}{\cn{gt}}
\\[0.5em]
\longrightarrow
&
\pcellb{0}{0}{r_1}
\pcellb{0}{1}{\cn{Ann}}
\pcellb{A}{1}{r_2}
\pcellb{\qrev{\cn{Bob}}{x}.0}{2}{\cn{Bob}}
\qcellb{R}{\cn{rel}}
\pcellb{A}{\cn{Ann} \rightarrow r_2}{\cn{comm}}
\qcellb{\cn{F}}{\cn{pred}}
\qcellb{3}{\cn{gt}}
&
(\rulelab{GC1})
\\[0.5em]
\longrightarrow
&
\pcellb{0}{0}{r_1}
\pcellb{0}{1}{\cn{Ann}}
\pcellb{A}{1}{r_2}
\pcellb{\qrev{\cn{Bob}}{x}.0}{2}{\cn{Bob}}
\qcellb{R}{\cn{rel}}
\pcellb{A}{\cn{Ann} \rightarrow r_2}{\cn{comm}}
\qcellb{b}{\cn{pred}}
\qcellb{3}{\cn{gt}}
&
(\rulelab{SP})
\end{array}
\]
\end{center}
}
{\footnotesize
\begin{center}
$A\triangleq\qsend{1}{\cn{Bob}}{m}^3
\qquad
b\triangleq\exists p'\,.\,(\cn{Ann},r_2,p')\in \cn{sp}(R,\cn{Ann},\cn{Bob})=\cn{F}
$
\end{center}
}

Assume that we start with an initial configuration as the top one above.
The relation $R$ defines a graph connectivity as in \Cref{fig:examplepath}.
The system began with a limited $2$ pieces of qubit resources for every cell 
and $r_1$'s resources were consumed previously. 
At this point, a message at the \cn{Ann} cell is waiting to transmit to either $r_1$ or $r_2$,
but we cannot apply rule \rulelab{GC1} to convey the message to $r_1$, since it has no enough resource; therefore, we transmit
the message to cell $r_2$.
Since $r_2$ is not part of the shortest path from $\cn{Ann}$ to $\cn{Bob}$, the application of rule \cn{SP} disqualifies the transition by marking the \cn{pred} cell to be $\cn{F}$; thus, the final configuration is stuck.

\noindent\textbf{The QCast Protocol.}
The above example shows that QPass can be unreasonable sometimes.
Since all message transmission paths are statically computed as the shortest paths,
it is possible that non shortest paths, such as the message transmission from \cn{Ann} to $r_2$ above, are omitted in the execution.
QCast overcomes this drawback by estimating different success rates for pairs in the \cn{rel} cell
and select a path with the highest estimated success rate, instead of selecting the shortest path in QPass.
Additionally, we update estimated success rates dynamically to reflect the rate reductions causing by qubit resource
consumption in different process cells.

Similar to QPass modeling, we utilize the configuration pattern and rules in \Cref{fig:q-pi-semantics3} except rule \rulelab{Grant1},
which is upgraded to rule \rulelab{MP} in \Cref{fig:qpass-rule}.
There are two key differences between rule \rulelab{MP} and \rulelab{SP}.
First, we now check if the pair $(c_1,c_2)$ is in the maximum success rate path from $c_1$ to $c$, computed by the function $\cn{mp}(R,c_1,c)$. Instead of checking if the pair is in a shortest path from $c_1$ to $c$ in QPass, we now find the path that can deliver a message in a maximum chance by firstly computing the estimated success rates for all different paths from $c_1$ to $c$ and then selecting the one having the maximum value. Second, we proportionally reduce the estimated success rates that are associated with relation pair $c_1$ and $c_2$ in the \cn{rel} cell. The qubit resources in process cells $c_1$ and $c_2$ are reduced, so paths through these two cells have a less likelihood to successfully transmit messages, compared to the case when qubit resources are enough,
whose behavior is captured by function $\cn{up}(R,c_1,n,c_2,m)$.
The simple explanation for the \cn{up} function is that
for every pair $(c_l,c_r,p)$ in $R$, if $c_l$ and $c_r$ are one of $c_1$ (or $c_2$), whose current qubit resource is $n$ (or $m$), we multiply $p$ by $\frac{n}{n+1}$ (or$ \frac{m}{m+1}$). 

{\footnotesize
\begin{center}
\[
\begin{array}{lll}
&
\pcellb{0}{0}{r_1}
\pcellb{A}{2}{\cn{Ann}}
\pcellb{0}{2}{r_2}
\pcellb{\qrev{\cn{Bob}}{x}.0}{2}{\cn{Bob}}
\qcellb{R'}{\cn{rel}}
\qcellb{\emptyset}{\cn{comm}}
\qcellb{\cn{F}}{\cn{pred}}
\qcellb{3}{\cn{gt}}
\\[0.5em]
\longrightarrow
&
\pcellb{0}{0}{r_1}
\pcellb{0}{1}{\cn{Ann}}
\pcellb{A}{1}{r_2}
\pcellb{\qrev{\cn{Bob}}{x}.0}{2}{\cn{Bob}}
\qcellb{R'}{\cn{rel}}
\pcellb{A}{\cn{Ann}\rightarrow r_2}{\cn{comm}}
\qcellb{\cn{F}}{\cn{pred}}
\qcellb{3}{\cn{gt}}
&
(\rulelab{GC1})
\\[0.5em]
\longrightarrow
&
\pcellb{0}{0}{r_1}
\pcellb{0}{1}{\cn{Ann}}
\pcellb{A}{1}{r_2}
\pcellb{\qrev{\cn{Bob}}{x}.0}{2}{\cn{Bob}}
\qcellb{\cn{up}(R',\cn{Ann},1,r_2,1)}{\cn{rel}}
\pcellb{A}{\cn{Ann}\rightarrow r_2}{\cn{comm}}
\qcellb{b}{\cn{pred}}
\qcellb{3}{\cn{gt}}
&
(\rulelab{MP})
\end{array}
\]
\end{center}
}
{\footnotesize
\begin{center}
$A\triangleq\qsend{1}{\cn{Bob}}{m}^3
\qquad
b\triangleq \exists p'\,.\,(\cn{Ann},r_2,p')\in \cn{mp}(R,\cn{Ann},\cn{Bob})=\cn{T}
$
\end{center}
}

The main purpose of the dynamic estimated success rate update is to take into account the qubit resources as a factor in message transmission. The above example starts with a similar initial configuration as the one above in discussing QPass. 
The \cn{rel} cell content $R'$ is updated before the execution, as the estimated success rate for the pair between $\cn{Ann}$ and $r_1$ has $0$ success rate, as $(\cn{Ann},r_1,0)$, because cell $r_1$ has no qubit resource. Then, the \rulelab{MP} rule application at the end grants the transition by marking cell \cn{pred} to be \cn{T}, since the path from \cn{Ann} to \cn{Bob} via $r_2$ has a higher success rate than the one via $r_1$. Additionally, we update the connectivity table $R'$ to $\cn{up}(R',\cn{Ann},1,r_2,1)$, by reducing the success rate on pairs related to cells $\cn{Ann}$ and $r_2$, proportion to the qubit resource reductions in the two cells.

Notice that the $\cn{up}$ function in rule \rulelab{MP} is a parameterized user definable function. 
If we parameterize the \cn{up} function to not update any success rates for relation triples in \cn{rel} cell, i.e., $\cn{up}(R,c_1,n,c_2,m)=R$, we can show that QPass probabilistically trace refines QCast, which is stated as follows:

\begin{theorem}\label{def:traceeq1}\rm[QPass and QCast Trace Refinement]
Given an initial configuration $C$ as an instantiation of the configuration pattern in \Cref{fig:q-pi-semantics3}, 
(QPass,$C$) $\sqsubseteq^p$ (QCast,$C$).

\end{theorem}

\subsection{Additional Quantum Network Properties}
\label{sec:add-prop}

\begin{figure}[t]
{\footnotesize

$\textcolor{blue}{\text{Extended Syntax:}}\\$
  \[\begin{array}{llcl} 
      \texttt{Success Rate Threshold} & \mu & \in & \Rs  \\[0.2em]
      \texttt{Message Success Rate Map} & g & \in & \Ls \times \Ms \rightharpoonup \Rs \\[0.2em]
      \texttt{Qubit Gen. Period} & \nu & \in & \Ts  \\[0.2em]
      \textcolor{red}{\texttt{Configuration Pattern GRF. Success Rate}} & \textcolor{red}{C_1} & \textcolor{red}{::=} & 
\textcolor{red}{\overline{\varphi}\pcell{\alpha}{\beta}{\cn{comm}}
  \qcell{\cn{bool}}{\cn{pred}}\qcell{R}{\cn{rel}}\qcell{t}{\cn{gt}}\pcell{g}{\mu}{\cn{at}} }\\[0.2em]
      \textcolor{red}{\texttt{Configuration Pattern for Qubit Gen.}} & \textcolor{red}{C_2} & \textcolor{red}{::=} & 
\textcolor{red}{\overline{\varphi}\pcell{\alpha}{\beta}{\cn{comm}}
  \qcell{\cn{bool}}{\cn{pred}}\qcell{R}{\cn{rel}}\qcell{t}{\cn{gt}}\pcell{\cn{bool}}{\nu}{\cn{qi}} }
    \end{array}
  \]
$\textcolor{blue}{\text{Semantics:}}\\$
  \begin{mathpar}
\mprset{flushleft}
  \inferrule[HP]{}
      {\qcell{R}{\cn{rel}}\pcell{(p.c.m)^t}{c_1}{\cn{comm}}\qcell{\cn{F}}{\cn{pred}}\qcell{t'}{\cn{gt}}\pcell{g}{\mu}{\cn{at}}
\\\qquad
        \longrightarrow 
            \qcell{R}{\cn{rel}}\pcell{(p.c.m)^t}{c_1}{\cn{comm}}\qcell{f(t,t')\wedge g(c.m)<\mu}{\cn{pred}}
        \qcell{t'}{\cn{gt}}\pcell{g[c.m\mapsto g(c.m)\oplus p]}{\mu}{\cn{at}}
      }

  \inferrule[QI1]{}
      {\pcell{P}{n}{c}\qcell{t}{\cn{gt}}\pcell{\cn{F}}{\nu}{\cn{qi}}
        \longrightarrow 
        \pcell{P}{n}{c}\qcell{t}{\cn{gt}}\pcell{\nu\cn{|}t}{\nu}{\cn{qi}}
      }

  \inferrule[QI2]{}
      {\pcell{P}{n}{c}\pcell{\cn{T}}{\nu}{\cn{qi}}
        \longrightarrow 
        \pcell{P}{n\cn{+}}{c}\pcell{\cn{F}}{\nu}{\cn{qi}}
      }

  \inferrule[TI]{}
      {\qcell{t}{\cn{gt}}
        \longrightarrow 
        \qcell{t\cn{+}}{\cn{gt}} \\\cn{[owise]}
      }

  \end{mathpar}
}
\caption{The additional rules for guaranteeing high success rate of deliveries and qubit resource generation based on \Cref{fig:q-pi-semantics3}, excluding rule \rulelab{Grant2}.}
  \label{fig:mes-rule}
\end{figure}

There are many different properties that we want to define for quantum network protocols.
Here, we introduce two properties that were discussed in the previous works but not captured by them. 
The first property is to guarantee a high success rate of every message delivery,
while the second one is to introduce qubit creation. 

\noindent\textbf{Guarantee High Probability of Message Deliveries.}
Quantum message communication has a certain chance of failure, which depends on the transmission distance.
To guarantee the success rate, one simple solution is to repeatedly send copies of the message until a success rate threshold is reached.
In \Cref{fig:mes-rule}, we extend the configuration pattern in \Cref{fig:q-pi-semantics3} with a new cell \cn{at} having a content map (partial function) $g$, storing the current success rates for different messages $c.m$, and a flag $\beta$, the success rate threshold every message needs to satisfy in $g$.
We then introduce the \rulelab{HP} granting rule, as a substitution of the \rulelab{Grant2} rule in \Cref{fig:q-pi-semantics3},
for granting a message delivery.
A message $c.m$ is valid to deliver if it satisfies the time threshold $f(t,t')$
and its current success rate in $g$ is less than the threshold $\mu$.
Once the threshold is reached, we do not need additional repetition of sending $c.m$.
Additionally, every success message delivery increments ($g[c.m\mapsto g(c.m)\oplus p]$) the current success rate for that message in the \cn{at} cell. If we view $p_a$ and $p_a$ as the likelihoods of events $a$ and $b$ happens, respectively,
$p_a\oplus p_b$ is defined as:
{\small
\begin{center}
$p_a\oplus p_b \triangleq 1 - (1-p_a)(1-p_b)$
\end{center}
}

To successfully model the property, we also need to modify the termination and stuck state conditions in \Cref{def:stuck},
by extending the terminated state condition to include an additional condition for guaranteeing all entries in $g$ satisfying the thredshold $\mu$.

\begin{definition}\label{def:stuck1}\rm[Additional Terminated State Condition]
A configuration $C$ is a terminated state if it satisfies the terminated state conditions in \Cref{def:stuck}, and:
\begin{itemize}
\item For the \cn{at} cell $\pcell{g}{\mu}{\cn{at}}$ in $C$, for every label $c.m$, if $g(c.m)\neq \bot$, $g(c.m)\ge \mu$.
\end{itemize}
$C$ is stuck if no rule is possible to apply to it and the above conditions are not satisfied.
\end{definition}

\begin{figure}[t]
{\footnotesize
\[\hspace*{-1em}
\begin{array}{l}
\begin{array}{lll}
&
\pcellb{\comp{P(1).0}}{10}{\cn{Cat}}
\pcellb{0}{10}{r_1}
\pcellb{\comp{Q.0}}{10}{\cn{Dan}} 
\qcellb{R}{\cn{rel}}
\qcellb{\emptyset}{\cn{comm}}
\qcellb{\cn{F}}{\cn{pred}}
\qcellb{0}{\cn{gt}}
\pcellb{g}{0.43}{\cn{at}}
\\[0.5em]
\longrightarrow&
\pcellb{\pard{P(1).0}{\comp{P(1).0}}}{10}{\cn{Cat}}
\pcellb{0}{10}{r_1}
\pcellb{\comp{Q.0}}{10}{\cn{Dan}} 
\qcellb{R}{\cn{rel}}
\qcellb{\emptyset}{\cn{comm}}
\qcellb{\cn{F}}{\cn{pred}}
\qcellb{0}{\cn{gt}}
\pcellb{g}{0.43}{\cn{at}}
&
(\rulelab{MT})
\\[0.5em]
\longrightarrow&
\pcellb{\pard{P(1)^0.0}{\comp{P(1).0}}}{10}{\cn{Cat}}
\pcellb{0}{10}{r_1}
\pcellb{\comp{Q.0}}{10}{\cn{Dan}} 
\qcellb{R}{\cn{rel}}
\qcellb{\emptyset}{\cn{comm}}
\qcellb{\cn{F}}{\cn{pred}}
\qcellb{0}{\cn{gt}}
\pcellb{g}{0.43}{\cn{at}}
&
(\rulelab{CT})
\\[0.5em]
\longrightarrow&
\pcellb{\comp{P(1).0}}{9}{\cn{Cat}}
\pcellb{P(0.5)^0.0}{9}{r_1}
\pcellb{\comp{Q.0}}{10}{\cn{Dan}} 
\qcellb{R}{\cn{rel}}
\pcellb{A}{\cn{Cat}\rightarrow r_1}{\cn{comm}}
\qcellb{\cn{F}}{\cn{pred}}
\qcellb{0}{\cn{gt}}
\pcellb{g}{0.43}{\cn{at}}
&(\rulelab{GC1},\rulelab{ID})
\end{array}
\\[0.5em]
\longrightarrow\;...\;\longrightarrow\\
\qquad\qquad\quad\;\;
\pcellb{\comp{P(1).0}}{9}{\cn{Cat}}
\pcellb{0}{8}{r_1}
\pcellb{\pard{P(0.25).0}{\pard{Q.0}{\comp{Q.0}}}}{9}{\cn{Dan}} 
\qcellb{R}{\cn{rel}}
\qcellb{\emptyset}{\cn{comm}}
\qcellb{\cn{F}}{\cn{pred}}
\qcellb{2}{\cn{gt}}
\pcellb{g}{0.43}{\cn{at}}
\\[0.5em]
\begin{array}{lll}
\longrightarrow&
\pcellb{\comp{P(1).0}}{9}{\cn{Cat}}
\pcellb{0}{8}{r_1}
\pcellb{\comp{Q.0}}{9}{\cn{Dan}} 
\qcellb{R}{\cn{rel}}
\pcellb{A(0)}{\cn{Dan}}{\cn{comm}}
\qcellb{\cn{F}}{\cn{pred}}
\qcellb{2}{\cn{gt}}
\pcellb{g}{0.43}{\cn{at}}
&
(\rulelab{Com},\rulelab{PC1},\rulelab{ID})
\\[0.5em]
\longrightarrow&
\pcellb{\comp{P(1).0}}{9}{\cn{Cat}}
\pcellb{0}{8}{r_1}
\pcellb{\comp{Q.0}}{9}{\cn{Dan}} 
\qcellb{R}{\cn{rel}}
\pcellb{A(0)}{\cn{Dan}}{\cn{comm}}
\qcellb{b}{\cn{pred}}
\qcellb{2}{\cn{gt}}
\pcellb{g_1}{0.43}{\cn{at}}
&
(\rulelab{HP})
\\[0.5em]
\xrightarrow{0.25.c.m}&
\pcellb{\comp{P(1).0}}{9}{\cn{Cat}}
\pcellb{0}{8}{r_1}
\pcellb{\comp{Q.0}}{9}{\cn{Dan}} 
\qcellb{R}{\cn{rel}}
\qcellb{\emptyset}{\cn{comm}}
\qcellb{\cn{F}}{\cn{pred}}
\qcellb{3}{\cn{gt}}
\pcellb{g_1}{0.43}{\cn{at}}
&
(\rulelab{AC1})
\end{array}
\\[0.5em]
\longrightarrow\;...\;\longrightarrow\\
\qquad\qquad\quad\;\;
\pcellb{\comp{P(1).0}}{8}{\cn{Cat}}
\pcellb{0}{6}{r_1}
\pcellb{\comp{Q.0}}{8}{\cn{Dan}} 
\qcellb{R}{\cn{rel}}
\pcellb{A(3)}{\cn{Dan}}{\cn{comm}}
\qcellb{\cn{F}}{\cn{pred}}
\qcellb{5}{\cn{gt}}
\pcellb{g_1}{0.43}{\cn{at}}
\\[0.5em]
\begin{array}{lll}
\longrightarrow&
\pcellb{\comp{P(1).0}}{8}{\cn{Cat}}
\pcellb{0}{6}{r_1}
\pcellb{\comp{Q.0}}{8}{\cn{Dan}} 
\qcellb{R}{\cn{rel}}
\pcellb{A(3)}{\cn{Dan}}{\cn{comm}}
\qcellb{b}{\cn{pred}}
\qcellb{5}{\cn{gt}}
\pcellb{g_2}{0.43}{\cn{at}}
&
(\rulelab{HP})
\\[0.5em]
\xrightarrow{0.25.c.m}  &
\pcellb{\comp{P(1).0}}{8}{\cn{Cat}}
\pcellb{0}{6}{r_1}
\pcellb{\comp{Q.0}}{8}{\cn{Dan}} 
\qcellb{R}{\cn{rel}}
\qcellb{\emptyset}{\cn{comm}}
\qcellb{\cn{F}}{\cn{pred}}
\qcellb{6}{\cn{gt}}
\pcellb{g_2}{0.43}{\cn{at}}
&
(\rulelab{AC1})
\\[0.5em]
\longrightarrow&
\pcellb{0}{8}{\cn{Cat}}
\pcellb{0}{6}{r_1}
\pcellb{\comp{Q.0}}{8}{\cn{Dan}} 
\qcellb{R}{\cn{rel}}
\qcellb{\emptyset}{\cn{comm}}
\qcellb{\cn{F}}{\cn{pred}}
\qcellb{6}{\cn{gt}}
\pcellb{g_2}{0.43}{\cn{at}}
&
(\rulelab{NT})
\\[0.5em]
\longrightarrow&
\pcellb{0}{8}{\cn{Cat}}
\pcellb{0}{6}{r_1}
\pcellb{0}{8}{\cn{Dan}} 
\qcellb{R}{\cn{rel}}
\qcellb{\emptyset}{\cn{comm}}
\qcellb{\cn{F}}{\cn{pred}}
\qcellb{6}{\cn{gt}}
\pcellb{g_2}{0.43}{\cn{at}}
&
(\rulelab{NT})
\end{array}
\end{array}
\]
}
{\footnotesize
\[
\begin{array}{l}
R\triangleq\{(\cn{Cat},r_1,0.5), (r_1,\cn{Dan},0.5)\}
\qquad
P\triangleq\qsend{1}{c}{m}.0
\qquad
Q\triangleq\qrev{c}{x}.0
\qquad
b\triangleq f(0,2)\wedge 0 < 0.43
\\
A\triangleq (0.5.c.m)^0
\qquad
A(t)\triangleq (0.25.c.m)^t
\qquad
g\triangleq\lambda x\,.\,\bot
\qquad
g_1=g[c.m \mapsto 0.25]
\qquad
g_2=g[c.m \mapsto 0.44]
\end{array}
\]
}
\caption{Example transitions based on the model for high success rate of deliveries.}
  \label{fig:q-pi-example1}
\end{figure}

\Cref{fig:q-pi-example1} shows an example transitions to guarantee high success rates for message deliveries.
Here, both the sender and receiver cells have repetition processes, 
$\comp{P(1).0}$ and $\comp{Q.0}$.
We first apply \cn{MT} rule application generates additional sending/receiving process to send/receive a message.
Then, a \cn{CT} rule application attaches time stamp $0$ to the message,
and the message is transmitted to the \cn{Dan} cell through the \rulelab{GC1} rule application,
with the success rate reducing to $0.5$.

After several steps, the message is transmitted to the \cn{Dan} cell with a success rate reduction to $0.25$.
We then apply the \rulelab{PC1} rule, with some intermediate transition rule applications, 
to deliver the message by communicating the processes $P(0.25).0$ and $Q.0$.
Then, we apply rule \rulelab{HP} to grant the message delivery labeled by $(0.25.c.m)^0$, because $f(0,2)$ is equivalent to $2-0<5$ and $g(c.m)=0$, less than the threshold $0.43$ in the \cn{at} cell.
In the \cn{at} cell, we updates map $g$ for $c.m$ to be $0.25$.
The procedure can be repeated to send more copies of message $c.m$ and then we can use \rulelab{HP} and \rulelab{AC1} rule applications to grant the message delivery and purge the configuration. 
In the above example, after two repeating $c.m$ message deliveries, the current success rate of $c.m$ is $0.44$ which is beyond the $0.43$ threshold. Any additional repetition causes the system to be stuck, so we apply two consecutive \rulelab{NT} rule applications to turn away the two repetition process operations and push the configuration to a terminated state.

\noindent\textbf{Modeling Qubit Generation.}
An useful property for quantum network protocols is to generate new qubit resources for supporting message transmissions.
For example, in the QPass protocol example in \Cref{sec:case-qpass}, if we can generate more resources for cell $r_1$, 
the message transmission via cell $r_1$ becomes possible.
In reality, generating qubit resources has a significant longer time period compared to transmitting/sending quantum messages.

In modeling the qubit generation mechanism, we include a new cell \cn{qi},
 based on the configuration pattern in \Cref{fig:q-pi-semantics3} as $C_2$ in \Cref{fig:mes-rule}.
We utilize the cell to determine if the qubit resources in a process cell can increment.
The additional flag $\nu$ defines the time period for generating a piece of resources.
Rule \rulelab{QI1} increments a piece of resources in cell $c$ if $\nu$ divides the current global time $t$ ($\nu \cn{|} t$),
while rule \rulelab{QI2} purges the \cn{qi} cell for next possible qubit increment computation.
By including the new rule \rulelab{QI1}, it is possible for a QAM system to reach deadlock,
because a system can be stuck due to lack of a qubit in a process cell, but in the very next time, the qubit resource in the cell can increment by applying rule \rulelab{QI1}; however, there is no rule in the system for the global clock cell \cn{gt} to increment by itself.
To overcome this, we include rule \rulelab{TI} here to allow self-increment in the \cn{gt} cell, 
with the flag $\cn{owise}$ meaning that the rule can be applied only if there is no other possible rules to apply.
For a QAM system $(\Ms,\Ls,\Ts,\overline{\rules})$, if $\rules$ is labeled with $\cn{owise}$,
for a configuration $C$, we can try to apply rule $\rules$ to $C$, only if for every $\rules' \in \overline{\rules} - \{\rules\}$ is not applicable to $C$.




